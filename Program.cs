// 2 лекция
// Задача 1. Нахождение max из 9 числе
//  1) Это стихийный подход

// int a1 = 15;
// int b1 = 21;
// int c1 = 39;
// int a2 = 313;
// int b2 = 23;
// int c2 = 33;
// int a3 = 13;
// int b3 = 23;
// int c3 = 33;

// int max = a1;
// if(b1>max)  max = b1;
// if(c1>max)  max = c1;

// if(a2>max)  max = a2;
// if(b2>max)  max = b2;
// if(c2>max)  max = c2;

// if(a3>max)  max = a3;
// if(b3>max)  max = b3;
// if(c3>max)  max = c3;

// Console.WriteLine(max);


// // 2) Воспользуемся для этого же решения Функциями

// int Max (int arg1, int arg2, int arg3)     // Прописали функцию. Возвращаем также целое число (int). Опишем аргументы.
// // Далее описываем тело метода (функции)
// //  Это вспомогательный механизм для поиска максимума из трех чисел. И это будем использовать дальше.
// // это кусочек кода, который отвечает за поиск максимума из трех чисел
// {
//     int result = arg1;                 // переменная, где хранится аргумент
//     if(arg2>result) result = arg2;           //   прописываем условия (сравниваем)
//     if(arg3>result) result = arg3;
//     return result;                         //   метод возвращает result
// }

// int a1 = 15;
// int b1 = 21;
// int c1 = 105;
// int a2 = 313;
// int b2 = 12365789;
// int c2 = 33;
// int a3 = 15647;
// int b3 = 23;
// int c3 = 33;

// // int max1 = Max(a1, b1, c1);
// // // По заданным данным и используя созданную функцию Max выбираем max из первых трех чисел, потом из второй тройки, и из третьей тройки
// // int max2 = Max(a2, b2, c2);
// // int max3 = Max(a3, b3, c3);

// // int max = Max(max1, max2, max3);
// // // Так же потом выбираем max из выбранных максимальных значений

// // Можно еще упростить, уменьшить кол-во строк: внутри аргумента передать функцию (можно в одну строку, а можно разнести для прочтения по строкам)

// int max = Max(
//           Max(a1, b1, c1), 
//           Max(a2, b2, c2), 
//           Max(a3, b3, c3));

// Console.WriteLine(max);


// // 3) Перепишем код используя массив (то же для этих же 9 элементов)

// // Воспользуемся для этого же решения Функциями

// int Max (int arg1, int arg2, int arg3)     
// {
//     int result = arg1;                 
//     if(arg2>result) result = arg2;           
//     if(arg3>result) result = arg3;
//     return result;                         
// }
// // Определим массив, вместо введения каждого элемента отдельно
// //             0  1   2   3   4  5   6   7  8
// int[] arrey = {101, 22, 3, 46, 25, 64, 7, 85, 9};

// // arrey[0]=12;     // присвоили первому элементу число 12 (выведется не 1 , 12)

// int max = Max(
//     Max(arrey[0], arrey[1], arrey[2]),
//     Max(arrey[3], arrey[4], arrey[5]),
//     Max(arrey[6], arrey[7], arrey[8])
// );
// Console.WriteLine(max);


// // Задача 2. Поиск позиции нужного нам элемента. 
// // 1). Имеется одномерный массив arrey из n элементов, троебуется найти элемент массива, равный find :
// //  - Установить счетчик index в позицию  0
// //  -(шаг 2) Если arrey[index] = find, алгоритм завершил работу успешно.
// //  - увеличить index на 1
// //  - если index < n, то перейти к шагу 2. В противном случае алгоритм завершил работу безуспешно.


// int[] arr = {1, 12, 53, 42, 51, 17, 67, 17, 80};
// //   Если несколько позиций, то покажет оба варианта.
// // Но если нужно, что бы показывал только первый подходящий то нужен новый оператор

// int n = arr.Length;

// int find = 17;     // это может быть любое число, может вводится пользователем по запросу, может получаться рандомно.
// int index = 0;        //  ввели счетчик

// while(index<n)
// {
//     if(arr[index]==find)         // совппдает обозначаем == (т.е. правая часть похожа на левую)
//     {
//         Console.WriteLine(index);   
//         break;             // эта команда остановит выполнение сразу же после нахождения первого нужного варианта
//     }
//     index++;
// }

// 2). Решим теперь с использованием генератолра пснвдослучайных чисел и с использованием метода  
// Взять метод - передать в него массив - заполнить массив.
// Опишем метод, который будет выводить все элементы по-порядку.
//  код поиска нужного интекса превратим в метод.

void FillArr(int[] collection)     //  collectin - это название аргумента/  Это первый метод - который заполнил массив
{
    int length = collection.Length;         // определяем длину массива
    int index = 0;
    while(index<length)
    {
        collection[index] = new Random().Next(1, 10);       // положим в аргумент с индексом новое число из промежутка от 1 до 10
        index++;
    }
}

void PrintArr(int[] col)                      // Это метод, который будет печатать массив
{
    int count = col.Length;
    int position = 0;
    while(position<count)
    {
        Console.WriteLine(col[position]);
        position++;
    }
}

int IndexOf(int[] collection, int find)
// метод отличный от void - он будет возвращать позицию / Приходит массив с аргументом collection и элементом find
{
    int count = collection.Length;
    int index=0;
    int position=-1;
// При отсутствии искомого элемента выводил 0, здесь тоже стоял ноль. Но если поменять на  -1, то при отсутсвии элемента будет выводить  -1.

    while(index<count)
    {
        if(collection[index]==find)
        {
            position = index;
            break;                // эта команда остановит поиск после первого найденного
        }
        index++;
    }
    return position;
}

int[] arr = new int[10];   // Дословно "создай новый массив, в котором будет 10 элементов. По умолчанию он наполнен  0 "

FillArr(arr);
arr[4] = 4;     // так искусственно ввели в массив четверки
arr[6] = 4;
PrintArr(arr);
Console.WriteLine();
int pos = IndexOf(arr, 444);
Console.WriteLine(pos);
// выводит последнюю занимаемую позицию из нескольких
//  но эта программа выдает 0 если указанного числа вообще нет, а это получается конфликт, т.к. 0 это индекс первого элемента массива

